import fire
from lolbo_nanocrystal.scripts.optimize import Optimize
from lolbo_nanocrystal.lolbo.nanocrystal_objective import NanoCrystalObjective
from lolbo_nanocrystal.lolbo.utils.nanocrystal_utils.models.data_utils import load_nanocrystal_train_data, compute_train_zs


class NanoCrystalOptimization(Optimize):
    """
    Run LOLBO Optimization for any Molecular Optimization Task using the SELFIES VAE 
    (Must be either a GuacaMol Task or the Penalized LogP task)

    Args:
        path_to_vae_statedict: Path to state dict of pretrained SELFIES VAE,
        max_string_length: Limit on string length that can be generated by VAE (without a limit we can run into OOM issues)
    """
    def __init__(
        self,
        path_to_vae_statedict: str=None,
        path_to_vae_ckpt: str="/sandbox/vkolluru/Gen_models_for_FANTASTX/May2023/1_LOLBO/practice/pt_model/m19/lightning_logs/NanoCrystalVAE/version_4/checkpoints/last.ckpt",
        nc_vae_params = None,
        init_train_X_path: str = None,
        init_train_Y_path: str = None,
        init_graph_embeds_path: str = None,
        fp_label: str='bag-of-bonds',
        fp_tolerances=[0.04, 0.7],
        path_to_energy_yaml: str=None,
        **kwargs
    ):
        self.path_to_vae_statedict = path_to_vae_statedict
        self.path_to_vae_ckpt = path_to_vae_ckpt
        self.nc_vae_params = nc_vae_params
        self.init_train_X_path = init_train_X_path
        self.init_train_Y_path = init_train_Y_path
        self.init_graph_embeds_path = init_graph_embeds_path
        self.fp_label = fp_label
        self.fp_tolerances = fp_tolerances
        self.path_to_energy_yaml = path_to_energy_yaml

        super().__init__(**kwargs)

        # add args to method args dict to be logged by wandb
        self.method_args['molopt'] = locals()
        del self.method_args['molopt']['self']

    def initialize_objective(self):
        # initialize molecule objective
        self.objective = NanoCrystalObjective(
            path_to_vae_statedict=self.path_to_vae_statedict,
            path_to_vae_ckpt=self.path_to_vae_ckpt,
            nc_vae_params=self.nc_vae_params,
            scaler_X=self.scaler_X,
            scaler_Y=self.scaler_Y,
            fp_label=self.fp_label,
            fp_tolerances=self.fp_tolerances,
            path_to_energy_yaml=self.path_to_energy_yaml
        )

        # if train zs have not been pre-computed for particular vae, compute them 
        #   by passing initialization selfies through vae 
        if self.init_train_z is None:
            self.init_train_z = compute_train_zs(
                self.objective,
                self.init_train_x_tensor,
                self.init_train_graph_embeds
            )

        return self

    def load_train_data(self):
        ''' Load in or randomly initialize self.num_initialization_points
            total initial data points to kick-off optimization 
            Must define the following:
                self.init_train_x (a list of x's)
                self.init_train_y (a tensor of scores/y's)
                self.init_train_z (a tensor of corresponding latent space points)
            '''
        assert self.num_initialization_points <= 20_000 
        
        self.init_train_x_keys, self.init_train_x_tensor, self.init_train_graph_embeds, \
                self.init_train_z, self.init_train_y, self.scaler_X, self.scaler_Y = \
                                load_nanocrystal_train_data(
                                    inp_arr_path=self.init_train_X_path, 
                                    y_vals_path=self.init_train_Y_path, 
                                    embds_path=self.init_graph_embeds_path
                                )
        # VSCK: init_train_x in molecules is divided into init_train_x_keys and init_train_x_tensor. 
        # Both will be used interchageably as required in the LOLBO framework
        #self.init_train_x_keys = ['sample_{i}' for i in range(self.init_train_x_tensor.shape[0])]
        if self.verbose:
            print("Loaded initial training data")

        return self


if __name__ == "__main__":
    fire.Fire(NanoCrystalOptimization)
